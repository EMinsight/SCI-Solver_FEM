#pragma once

#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <cusp/array1d.h>
#include <cusp/csr_matrix.h>
#include <cusp/graph/maximal_independent_set.h>
#include <types.h>
#include <TriMesh.h>
#include <tetmesh.h>

typedef cusp::coo_matrix<int, int, cusp::device_memory> devMtx;
typedef cusp::csr_matrix<int, int, cusp::host_memory> hostMtx;
typedef thrust::device_vector<int> IntVector_d;
typedef thrust::device_vector<float> FloatVector_d;

namespace misHelpers
{   
    struct subtractFrom
    {
        const int a;
        
        subtractFrom(int _a): a(_a){}
        
        __host__ __device__
        int operator()(const int &x) const
        {
            return x - a;
        }
        
    };
    
    struct ifLabelOne
    {
        __host__ __device__
        int operator()(const int &a, const int &b) const
        {
            if (b == 0)
                return -1;
            
            return a - 1;
        }
    };
    
    struct removePart
    {
        const int a;
        
        removePart(int _a): a(_a){}
        
        __host__ __device__
        int operator()(const int &x) const
        {
            if (x == a)
                return -1;
         
            if (x > a)
                return x - 1;
            
            return x;
        }
    };
    
    struct findAggregated
    {   
        __host__ __device__
        int operator()(const int &a) const
        {
            if (a == -1)
                return 0;
            else
                return 1;
        }
    };
    
    struct lessThan
    {
        const int a;
        
        lessThan(int _a): a(_a){}
        
        __host__ __device__
        int operator()(const int &x) const
        {
            return x < a;
        }
    };
    
    struct labelLessThan
    {
        const int a;
        
        labelLessThan(int _a): a(_a){}
        
        __host__ __device__
        int operator()(const int &x) const
        {
            return x < a ? 1 : 0;
        }
    };
    
    void getSizes(IdxVector_d &adjIndexes, IdxVector_d &sizes);
    
    void getMIS(IdxVector_d &adjIndexes, IdxVector_d &adjacency, IdxVector_d &misStencil, int depth);
    
    void getAdjacency(TriMesh * meshPtr, IdxVector_d &adjIndexes, IdxVector_d &adjacency);
    
    void getAdjacency(TetMesh * meshPtr, IdxVector_d &adjIndexes, IdxVector_d &adjacency);
    
    void aggregateGraph(int minSize, int depth, IdxVector_d &adjIndexes, IdxVector_d &adjacency, IdxVector_d &misStencil);
    
    void aggregateWeightedGraph(int maxSize, int fullSize, int depth, IdxVector_d &adjIndexes, IdxVector_d &adjacency, IdxVector_d &partIn, IdxVector_d &nodeWeights);
    
    bool removeRuntyParts(int minSize, IdxVector_d &partition);
    
    bool removeRuntyPartitions(int minSize, IdxVector_d &partition, IdxVector_d &nodeWeights);
    
    void getPartSizes(IdxVector_d &partition, IdxVector_d &partSizes);
    
    void getPartSizes(IdxVector_d &partition, IdxVector_d &partSizes, IdxVector_d &partIndices);
    
    void getPartIndices(IdxVector_d &sortedPartition, IdxVector_d &partIndices);
    
    void getPartIndicesNegStart(IdxVector_d& sortedPartition, IdxVector_d& partIndices);
    
    void fillWithIndex(IdxVector_d &tofill);
    
    void getInversePermutation(IdxVector_d &original, IdxVector_d &inverse);
    
    void permuteInitialAdjacency(IdxVector_d &adjIndexesIn, IdxVector_d &adjacencyIn, IdxVector_d &permutedAdjIndexesIn, IdxVector_d &permutedAdjacencyIn, IdxVector_d &ipermutation, IdxVector_d &fineAggregate);
    
    void getInducedGraphNeighborCounts(IdxVector_d &aggregateIdx, IdxVector_d &adjIndexesOut, IdxVector_d &permutedAdjIndexesIn, IdxVector_d &permutedAdjacencyIn);
    
    void fillCondensedAdjacency(IdxVector_d &aggregateIdx, IdxVector_d &adjIndexesOut, IdxVector_d &adjacencyOut, IdxVector_d &permutedAdjIndexesIn, IdxVector_d &permutedAdjacencyIn);
    
    void fillPartitionLabel(IdxVector_d &coarseAggregate, IdxVector_d &fineAggregateSort, IdxVector_d &partitionLabel);
    
    void getAggregateStartIndices(IdxVector_d &fineAggregateSort, IdxVector_d &aggregateRemapIndex);
    
    void remapAggregateIdx(IdxVector_d &fineAggregateSort, IdxVector_d &aggregateRemapId);
    
    void mapAdjacencyToBlock(IdxVector_d &adjIndexes, IdxVector_d &adjacency, IdxVector_d &adjacencyBlockLabel, IdxVector_d &blockMappedAdjacency, IdxVector_d &fineAggregate);
    
    void getInducedGraph(IdxVector_d &adjIndexesIn, IdxVector_d &adjacencyIn, IdxVector_d &partitionLabel, IdxVector_d &adjIndexesOut, IdxVector_d &adjacencyOut);
    
    void restrictPartitionSize(int maxSize, int fullSize, IdxVector_d &adjIndexes, IdxVector_d &adjacency, IdxVector_d &partition, IdxVector_d &nodeWeights);
    
    void getWeightedPartSizes(IdxVector_d &partition, IdxVector_d &nodeWeights, IntVector_d &partSizes);
    
    void checkPartConnectivity(int partCount, IdxVector_d partition, IdxVector_d adjIndexes, IdxVector_d adjacency, char *message);
}
